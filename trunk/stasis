#!/usr/bin/perl -w

# Copyright (c) 2008, Gian Merlino
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;
use lib 'lib';
use open ':encoding(utf8)';
use Stasis::Parser;
use Stasis::LogSplit;
use Stasis::ClassGuess;
use Stasis::Extension;
use Stasis::ChartPage;
use Stasis::ActorPage;
use Stasis::SpellPage;
use Stasis::ActorGroup;
use Stasis::PageMaker;
use Stasis::DB;
use Data::Dumper;
use File::Find qw();
use File::Path qw();
use File::Spec qw();
use File::Copy qw(copy);
use POSIX;
use HTML::Entities;
use Getopt::Long;

## OPTIONS ##
my $opt_version = 2;
my $opt_minlength = 30;
my $opt_sfile;
my $opt_dir = ".";
my $opt_nowrite;
my $opt_logger;
my $opt_file;
my $opt_attempts;
my $opt_year;
my $opt_trash;
my $opt_overall;
my $opt_server;
my $opt_collapse;

## SUBS ##

sub usage {
    my ($exitvalue) = @_;
    $exitvalue ||= 1;

    my $me = $0;
    $me =~ s/^.*\///;
    print STDERR <<USAGE;
Usage:
    $me action [options]

There are 2 main actions:
    history    Updates the wws-history/data.xml in the specified
               directory with all accumulated data of all sws-* dirs.

    add        Read a combat log and write out parsed HTML corresponding
               to the encounters found within in.

Options:
    -file      Specifies the combat log to read.

    -dir       Specifies in which directory the generated HTML is living
               or will be written, depending on action. Default is the
               current directory.

    -version   Either 1 or 2. Pre-2.4 combatlogs should be parsed with
               version = 1, post-2.4 combatlogs with 2. Default is '2',
               the new post-2.4 style.

    -logger    Name of the logger, optional argument only used when parsing
               version 1 combat logs. Default is 'You'.

    -minlength Exclude encounters less than this amount of seconds in length.
               Defaults to 30 seconds.
               
    -attempts  Include a parse for boss attempts (not just kills).
                   
    -trash     Include a parse for trash mobs (all sections of the log that
               were not part of a boss encounter).
               
    -overall   Include a separate parse that rolls up everything in the log
               file.
               
    -collapse  For boss attempts and kills, collapse all mobs that have the
               same NPC ID and all pets with the same name and owner. This
               is always done for trash parses to save space, but by default
               is not done for boss parses.

Example for parsing boss kills only:
    $me add -dir /var/www/sws -file WoWCombatLog.txt

Example for parsing every single line in a log:
    $me add -dir /var/www/sws -file WoWCombatLog.txt -attempt -trash -overall

Example for updating the wws-history/data.xml:
    $me history -dir /var/www/swstats.domain.com

USAGE
    exit $exitvalue;
}

sub bomb($) {
    my $msg = shift;
    my $prog = $0;
    $msg =~ s/^/$prog: /gm;
    chomp $msg;
    print STDERR $msg . "\n";
    exit 1;
}

sub status($) {
    my $msg = shift;
    my $prog = $0;
    
    if( $msg !~ /^[a-z]/ ) {
        $msg =~ s/^/$prog: /gm;
    }
    
    chomp $msg;
    if( $msg =~ /\.\.\s*$/ ) {
        print STDERR $msg;
    } else {
        print STDERR $msg . "\n";
    }
}

sub makeext() {
    my $ret = {};
    foreach (qw(Activity Damage Death Healing Aura Cast ExtraAttack Interrupt Power Presence Index)) {
        $ret->{$_} = Stasis::Extension->factory($_);
        $ret->{$_}->start();
    }
    
    return $ret;
}

sub writedir($$$$$$$) {
    my ($dname, $dname_old, $long, $short, $raid, $exts, $collapse) = @_;
    
    # Remove the directory if it exists.
    File::Path::rmtree($dname) if -d $dname;
    File::Path::rmtree($dname_old) if -d $dname_old;

    # Create the directory.
    mkdir $dname or die $!;

    # Write the index.
    my $charter = Stasis::ChartPage->new( name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    my ($chart_xml, $chart_html) = $charter->page;
    open CHARTPAGE, ">$dname/index.html" or die;
    print CHARTPAGE $chart_html;
    close CHARTPAGE;
    
    # Group actors.
    my $grouper = Stasis::ActorGroup->new;
    $grouper->run( $raid, $exts );

    # Write the actor files.
    my $ap = Stasis::ActorPage->new( server => $opt_server, name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    foreach my $actor (keys %{$exts->{Presence}{actors}}) {
        # Respect $collapse.
        next if $collapse && $grouper->group($actor);
        
        my $id = lc $actor;
        $id = Stasis::PageMaker->tameText($id);

        open ACTORPAGE, sprintf ">$dname/actor_%s.html", $id or die;
        print ACTORPAGE $ap->page($actor);
        close ACTORPAGE;
    }
    
    # Write the group files.
    foreach my $group (@{$grouper->{groups}}) {
        my $id = lc $grouper->captain($group);
        $id = Stasis::PageMaker->tameText($id);
        
        open GROUPPAGE, sprintf ">$dname/group_%s.html", $id or die;
        print GROUPPAGE $ap->page($grouper->captain($group), 1);
        close GROUPPAGE;
    }
    
    # Write the environment file.
    open ENVPAGE, ">$dname/actor_0.html" or die;
    print ENVPAGE $ap->page(0);
    close ENVPAGE;
    
    # Write the spell files.
    my $sp = Stasis::SpellPage->new( name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    foreach my $spell (keys %{$exts->{Index}{spells}}) {
        my $id = lc $spell;
        $id = Stasis::PageMaker->tameText($id);

        open SPELLPAGE, sprintf ">$dname/spell_%s.html", $id or die;
        print SPELLPAGE $sp->page($spell);
        close SPELLPAGE;
    }

    # Write the data.xml file.
    open DATAXML, ">$dname/data.xml" or die;
    print DATAXML $chart_xml;
    close DATAXML;
}

# For File::Find later
my @dataxmls;
sub wantedDataXML {
    if( -f $_ && ( $File::Find::name =~ /\/sws-[0-9]+\/data.xml$/ || $File::Find::name =~ /\/sws-[\w]+-[0-9]+\/data.xml$/ ) ) {
        push @dataxmls, $File::Find::name;
    }
}

## CODE ##

# Get the action first.
usage(0) unless @ARGV;
my $action = lc shift @ARGV;
usage(0) if $action eq "-h" || $action eq "help" || $action eq "-help" || $action eq "--help";

# Get options.
my $rc = GetOptions(
    "version=s"     => \$opt_version,
    "logger=s"      => \$opt_logger,
    "file=s"        => \$opt_file,
    "dir=s"         => \$opt_dir,
    "minlength=i"   => \$opt_minlength,
    "attempts"      => \$opt_attempts,
    "nowrite"       => \$opt_nowrite,
    "year=i"        => \$opt_year,
    "sfile=s"       => \$opt_sfile,
    "trash"         => \$opt_trash,
    "overall"       => \$opt_overall,
    "server=s"      => \$opt_server,
    "collapse"      => \$opt_collapse,
);

# Clean up opt_dir
if( $opt_dir ) {
    $opt_dir = File::Spec->rel2abs($opt_dir);
}

# Create a parser.
my $parser = Stasis::Parser->new( ref => 1, version => $opt_version, logger => $opt_logger, year => $opt_year );

# Set encoding of STDOUT to UTF-8 (which Blizzard uses for combat logs)
binmode(STDOUT, ":utf8");

# Case out the various actions.
if( $action eq "print" ) {
    # action PRINT: used to print out actions from a log file
    
    # Figure out what input to use.
    my $db;
    my $fh;
    
    if( $opt_file ) {
        # Get a filehandle.
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } elsif( $opt_sfile ) {
        # Get a database connection.
        status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
        $db = Stasis::DB->new( db => $opt_sfile );
        $db->line(1);
    } else {
        bomb "STDIN is no longer supported, please use -file or -sfile (see 'stasis help' for more details)";
    }
    
    while( defined( $_ = $opt_file ? <$fh> : $db->line() ) ) {
        my $entry = $opt_file ? $parser->parse($_) : $_;
        if( $entry->{action} ) {
            if( my $text = $parser->toString( $entry ) ) {
                $entry->{t} =~ /^(\d+)(\.(\d+)|)$/;
                my @t = localtime $1;
                printf "%d/%d %02d:%02d:%02d\.%03d  %s\n", $t[4]+1, $t[3], $t[2], $t[1], $t[0], $2?$3:0, $text;
            }
        }
    }
} elsif( $action eq "add" ) {
    # Figure out what input to use.
    my $fh;
    my $db;
    
    if( $opt_file ) {
        # Get a filehandle.
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } elsif( $opt_sfile ) {
        # Get a database connection.
        status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
        $db = Stasis::DB->new( db => $opt_sfile );
        $db->line(1);
    } else {
        bomb "STDIN is no longer supported, please use -file or -sfile (see 'stasis help' for more details)";
    }
    
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Assign classes to %raid and splits to @splits
    status "Reading log .. ";
    
    my @boss;
    my %trash_exts = %{makeext()};
    my %overall_exts = %{makeext()};
    my $classer = Stasis::ClassGuess->new( version => $opt_version );
    my $splitter = Stasis::LogSplit->new( version => $opt_version, callback =>
        # LogSplit callback
        sub {
            my ($short, $long, $kill, $start, $end) = @_;
            if( ! defined $kill ) {
                # Starting a new split.
                push @boss, {
                    exts => makeext,
                    short => $short,
                };
            } else {
                # Closing or deleting a split.
                foreach (@boss) {
                    if( !$_->{long} && $_->{short} eq $short ) {
                        $_->{long} = $long;
                        $_->{kill} = $kill;
                        $_->{start} = $start;
                        $_->{end} = $end;
                        
                        foreach my $e (values %{$_->{exts}}) {
                            $e->finish();
                        }
                    }
                }
            }
        }
    );
    
    # Keep track of when the log started.
    my $first = 0;
    
    while( defined( $_ = $opt_file ? <$fh> : $db->line() ) ) {
        # Get the line.
        my $pline = $opt_file ? $parser->parse($_) : $_;
        $classer->process($pline);
        $splitter->process($pline);

        if( !$first ) {
            $first = $pline->{t};
        }
        
        my $bosses = 0;
        foreach my $b (@boss) {
            next if defined $b->{kill};
            
            $bosses ++;
            foreach my $ext (values %{$b->{exts}}) {
                $ext->process($pline);
            }
        }
        
        if( !$bosses && $opt_trash ) {
            # Do the trash parse if it was requested.
            foreach my $ext (values %trash_exts) {
                $ext->process($pline);
            }
        }
        
        # Add to the overall parse.
        if( $opt_overall ) {
            foreach my $ext (values %overall_exts) {
                $ext->process($pline);
            }
        }
    }
    
    if( $opt_trash ) {
        foreach my $ext (values %trash_exts) {
            $ext->finish();
        }
    }
    
    if( $opt_overall ) {
        foreach my $ext (values %overall_exts) {
            $ext->finish();
        }
    }
    
    my %raid = $classer->finish();
    my @splits = $splitter->finish();
    
    # Remove these tools.
    undef $classer;
    undef $splitter;
    
    # Close the file.
    if( $opt_file ) {
        close $fh;
    } else {
        $db->disconnect();
    }
    
    # Count the results so the user can see what's up.
    my $n_players = 0;
    my $n_pets = 0;
    while( my ($rid, $rdata) = each(%raid) ) {
        if( $rdata->{class} ne "Pet" ) {
            $n_players ++;
        } else {
            $n_pets ++;
        }
    }
    
    status 
            "found $n_players player" . ($n_players == 1 ? "" : "s") . 
            ", $n_pets pet" . ($n_pets == 1 ? "" : "s") . 
            ", and " . scalar(@splits) . " boss encounter" . (scalar(@splits) == 1 ? "" : "s") . ".";
    
    # Write boss encounters
    foreach my $b (@boss) {
        warn "possible error in log splitter" if !defined $b->{kill};
        
        if( $opt_minlength && $b->{end} - $b->{start} < $opt_minlength ) {
            # Check minlength option.
            status sprintf "Skipping: %s (too short).", $b->{long};
        } elsif( !$opt_attempts && !$b->{kill} ) {
            # Check attempts option.
            status sprintf "Skipping: %s (not a kill).", $b->{long}, $b->{end} - $b->{start};
        } else {
            # If we got this far, we should write this encounter.
            status sprintf "Writing: %s (sws-%s-%d) .. ", $b->{long}, $b->{short}, floor($b->{start});

            # Find the directory name.
            my $dname = sprintf "%s/sws-%s-%d", $opt_dir, $b->{short}, floor($b->{start});
            my $dname_old = sprintf "%s/sws-%d", $opt_dir, floor($b->{start});

            # Write the files for this split.
            unless( $opt_nowrite ) {
                eval {
                    writedir $dname, $dname_old, $b->{long}, $b->{short}, \%raid, $b->{exts}, $opt_collapse;
                }; if( $@ ) {
                    bomb $@;
                }
            }
            
            status "done.";
        }
    }
    
    # Write trash
    if( $opt_trash && !$opt_nowrite ) {
        my $dname = sprintf "%s/sws-trash-%d", $opt_dir, floor($first);
        my $dname_old = $dname;
        
        foreach my $ext (values %trash_exts) {
            $ext->finish();
        }
        
        unless( $opt_nowrite ) {
            eval {
                writedir $dname, $dname_old, "Trash Mobs", "trash", \%raid, \%trash_exts, 1;
            }; if( $@ ) {
                bomb $@;
            }
        }
        
        status sprintf "Wrote: Trash Mobs (sws-trash-%d).", floor($first);
    }
    
    # Write overall
    if( $opt_overall && !$opt_nowrite ) {
        my $dname = sprintf "%s/sws-overall-%d", $opt_dir, floor($first);
        my $dname_old = $dname;
        
        foreach my $ext (values %overall_exts) {
            $ext->finish();
        }
        
        unless( $opt_nowrite ) {
            eval {
                writedir $dname, $dname_old, "Overall", "overall", \%raid, \%overall_exts, 1;
            }; if( $@ ) {
                bomb $@;
            }
        }
        
        status sprintf "Wrote: Overall (sws-overall-%d).", floor($first);
    }
    
} elsif( $action eq "history" ) {
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Header
    my $xml = "<wws-history>\n";
    
    # Look at all data.xmls.
    @dataxmls = ();
    File::Find::find( \&wantedDataXML, ($opt_dir) );
    
    status "Reading from " . (scalar @dataxmls) . " subdirectories.";
    
    foreach my $dataxml (@dataxmls) {
        open DXML, $dataxml or die "Could not open a subdirectory for reading.";
        while( <DXML> ) {
            $xml .= $_;
        }
        close DXML;
    }
    
    # Footer
    $xml .= "</wws-history>\n";
    
    # Create wws-history directory if it doesn't exist.
    if( ! -d $opt_dir . "/wws-history" ) {
        mkdir $opt_dir . "/wws-history" or bomb "Could not create extras directory";
    }
    
    open DXML, ">$opt_dir/wws-history/data.xml" or die "Could not open data.xml for writing";
    print DXML $xml;
    close DXML;
    
    status "Wrote: $opt_dir/wws-history/data.xml";
    
    # Copy JS and CSS
    my $prog = $0;
    $prog =~ s/\/[^\/]*$//;
    my $extra_path = File::Spec->catdir( File::Spec->rel2abs($prog), "extras" );
    
    if( -d $extra_path && -f "$extra_path/sws.js" && -f "$extra_path/sws2.css" ) {
        status "Copying extras from: $extra_path";
        
        # Create extras directory if it doesn't exist
        if( ! -d $opt_dir . "/extras" ) {
            mkdir $opt_dir . "/extras" or die;
        }
        
        # Copy JS and CSS
        copy( "$extra_path/sws.js", "$opt_dir/extras/sws.js" ) or die;
        status "Wrote: $opt_dir/extras/sws.js";
        
        copy( "$extra_path/sws2.css", "$opt_dir/extras/sws2.css" ) or die;
        status "Wrote: $opt_dir/extras/sws2.css";
    } else {
        bomb "Could not find extras dir: checked $extra_path";
    }
} elsif( $action eq "convert" ) {
    status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
    
    # Figure out the filehandle to use.
    my $fh;
    if( $opt_file ) {
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } else {
        bomb "STDIN is no longer supported, please use -file (see 'stasis help' for more details)";
    }
    
    # Get a database connection.
    my $db = Stasis::DB->new( db => $opt_sfile );
    
    if( -e $opt_sfile ) {
        # Bail if the file exists.
        bomb "target file exists, choose another name: $opt_sfile";
    }
    
    eval {
        # Create the target file.
        $db->create();
        
        # Import log entries.
        my $nlog = -1;
        while( <$fh> ) {
            $nlog++;
            my $entry = $parser->parse($_);
            $db->addLine( $nlog, $entry );
        }
        
        $db->finish();
        $db->disconnect();
    }; if( $@ ) {
        bomb "convert error: $@";
        unlink $opt_sfile;
    }
} else {
    bomb "bad action: $action";
}

exit 0;
