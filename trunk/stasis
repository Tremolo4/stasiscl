#!/usr/bin/perl -w

# Copyright (c) 2008, Gian Merlino
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=head1 NAME

stasis - WoW combat log parser

=head1 DESCRIPTION

This program will read in a WoW combat log and then perform some action that
you specify. Generally this will be 'add', which runs some calculations on
the log and writes out HTML, or 'print' which prints out the log in a nicer
format.

For more information visit I<http://code.google.com/p/stasiscl/>.

=head1 SYNOPSIS

Write HTML for boss kills in the directory C</var/www/sws>:
    stasis add -dir /var/www/sws -file WoWCombatLog.txt

Write HTML for kills and attempts:
    stasis add -dir /var/www/sws -file WoWCombatLog.txt -attempt

Update the wws-history/data.xml:
    stasis history -dir /var/www/sws

=head1 USAGE

    stasis action [options]

=head2 Actions

You must provide one of these as the first command-line argument.

B<add>        Read a combat log and write out parsed HTML corresponding
           to the encounters found within in.

B<print>      Display a pretty-printed version of the combat log.
                      
B<history>    Updates the wws-history/data.xml in the specified
           directory with all accumulated data of all sws-* dirs.


B<convert>    Convert a combat log into a SQLite database.
           WARNING: This feature is experimental and subject to change!

=head2 Options

You may provide various options after the action. Some of them will be
required and some will be optional, depending on what action you select.

B<-file>      Specifies the combat log to read.

B<-dir>       Specifies in which directory the generated HTML is living
           or will be written, depending on action. Default is the
           current directory.
           
B<-server>    If present, Armory links will be included using this server.
           Only works with the US armory for now.

B<-version>   Either 1 or 2. Pre-2.4 combatlogs should be parsed with
           version = 1, post-2.4 combatlogs with 2. Default is '2',
           the new post-2.4 style.

B<-logger>    Name of the logger, optional argument only used when parsing
           version 1 combat logs. Default is 'You'.

B<-minlength> Exclude encounters less than this amount of seconds.
           Defaults to 30 seconds.
           
B<-attempt>  Include a parse for boss attempts (not just kills).
               
B<-trash>     Include a parse for trash mobs (all sections of the log that
           were not part of a boss encounter).

B<-combine>   Include a parse that rolls up all attempts and kills on each
           particular boss (one extra parse per boss).

B<-overall>   Include a separate parse that rolls up everything in the log
           file.
           
B<-collapse>  For boss attempts and kills, collapse all mobs that have the
           same NPC ID and all pets with the same name and owner. This
           is always done for trash parses to save space, but by
           default is not done for boss parses.
           
B<-meta>      Include "meta buffs" in the aura display, such as Mangle,
           Faerie Fire, and +25% Armor.

=head1 BUGS

http://code.google.com/p/stasiscl/

Use the "Issues" tab.

=cut

use strict;
use warnings;
use lib 'lib';
use open ':encoding(utf8)';
use Stasis::Parser;
use Stasis::LogSplit;
use Stasis::ClassGuess;
use Stasis::Extension;
use Stasis::ExtensionRunner;
use Stasis::EventDispatcher;
use Stasis::ChartPage;
use Stasis::ActorPage;
use Stasis::SpellPage;
use Stasis::ActorGroup;
use Stasis::PageMaker;
use Stasis::LogClip;
use Stasis::DB;
use File::Find ();
use File::Path ();
use File::Spec ();
use File::Copy qw(copy);
use POSIX;
use HTML::Entities;
use Getopt::Long;

## OPTIONS ##
my $opt_version = 2;
my $opt_minlength = 30;
my $opt_sfile;
my $opt_dir = ".";
my $opt_nowrite;
my $opt_logger;
my $opt_file;
my $opt_attempts;
my $opt_year;
my $opt_trash;
my $opt_overall;
my $opt_combine;
my $opt_server;
my $opt_collapse;
my $opt_tail;
my $opt_meta;

## SUBS ##

sub usage {
    my ($exitvalue) = @_;
    $exitvalue ||= 1;

    my $me = $0;
    $me =~ s/^.*\///;
    print STDERR <<USAGE;
Usage: $me action [options]
See 'perldoc stasis'.
USAGE

    exit $exitvalue;
}

sub bomb($) {
    my $msg = shift;
    my $prog = $0;
    $msg =~ s/^/$prog: /gm;
    chomp $msg;
    print STDERR $msg . "\n";
    exit 1;
}

sub status($) {
    my $msg = shift;
    my $prog = $0;
    
    if( $msg !~ /^[a-z]/ ) {
        $msg =~ s/^/$prog: /gm;
    }
    
    chomp $msg;
    if( $msg =~ /\.\.\s*$/ ) {
        print STDERR $msg;
    } else {
        print STDERR $msg . "\n";
    }
}

sub makeext() {
    Stasis::ExtensionRunner->new(qw(Activity Aura Cast Damage Death Dispel ExtraAttack Healing Index Interrupt Power Presence));
}

sub writedir($$$$$$$) {
    my ($dname, $dname_old, $long, $short, $raid, $exts, $collapse) = @_;
    
    # Remove the directory if it exists.
    File::Path::rmtree($dname) if -d $dname;
    File::Path::rmtree($dname_old) if -d $dname_old;

    # Create the directory.
    mkdir $dname or die $!;
    
    # Get the suffix of the directory.
    my $dname_suffix = $dname;
    $dname_suffix = $1 if $dname_suffix =~ /[\/\\:]([^\/\\:]+)$/;

    # Write the index.
    my $charter = Stasis::ChartPage->new( name => $long, dirname => $dname_suffix, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    my ($chart_xml, $chart_html) = $charter->page;
    open CHARTPAGE, ">$dname/index.html" or die;
    print CHARTPAGE $chart_html;
    close CHARTPAGE;
    
    # Group actors.
    my $grouper = Stasis::ActorGroup->new;
    $grouper->run( $raid, $exts );

    # Write the actor files.
    my $ap = Stasis::ActorPage->new( meta => $opt_meta, server => $opt_server, dirname => $dname_suffix, name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    foreach my $actor (keys %{$exts->{Presence}{actors}}) {
        # Respect $collapse.
        next if $collapse && $grouper->group($actor);
        
        my $id = lc $actor;
        $id = Stasis::PageMaker->tameText($id);

        open ACTORPAGE, sprintf ">$dname/actor_%s.html", $id or die;
        print ACTORPAGE $ap->page($actor);
        close ACTORPAGE;
    }
    
    # Write the group files.
    foreach my $group (@{$grouper->{groups}}) {
        my $id = lc $grouper->captain($group);
        $id = Stasis::PageMaker->tameText($id);
        
        open GROUPPAGE, sprintf ">$dname/group_%s.html", $id or die;
        print GROUPPAGE $ap->page($grouper->captain($group), 1);
        close GROUPPAGE;
    }
    
    # Write the environment file.
    open ENVPAGE, ">$dname/actor_0.html" or die;
    print ENVPAGE $ap->page(0);
    close ENVPAGE;
    
    # Write the spell files.
    my $sp = Stasis::SpellPage->new( name => $long, dirname => $dname_suffix, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    foreach my $spell (keys %{$exts->{Index}{spells}}) {
        my $id = lc $spell;
        $id = Stasis::PageMaker->tameText($id);

        open SPELLPAGE, sprintf ">$dname/spell_%s.html", $id or die;
        print SPELLPAGE $sp->page($spell);
        close SPELLPAGE;
    }
    
    # Write death clips.
    my $lc = Stasis::LogClip->new( raid => $raid, ext => $exts );
    while( my ($kactor, $vactor) = each(%{$exts->{Death}{actors}}) ) {
        my $id = lc $kactor;
        $id = Stasis::PageMaker->tameText($id);
        
        my $dn = 0;
        foreach my $death (@$vactor) {
            $lc->clear;
            foreach my $entry (@{$death->{autopsy}}) {
                $lc->add( $entry->{entry}, hp => $entry->{hp}, t => $entry->{t} );
            }
            
            open DEATHPAGE, sprintf ">$dname/death_%s_%d.html", $id, ++$dn or die;
            print DEATHPAGE $lc->json;
            close DEATHPAGE;
        }
    }

    # Write the data.xml file.
    open DATAXML, ">$dname/data.xml" or die;
    print DATAXML $chart_xml;
    close DATAXML;
}

sub lagstring($) {
    my $lag = shift;
    
    my $lagstring;
    if( $lag < 0 ) {
		$lagstring = " in the future";
		$lag *= -1;
	} else {
		$lagstring = " ago";
	}
    
	if( $lag < 60 ) {
		$lagstring = sprintf "%d second%s%s", $lag, $lag == 1 ? '' : 's', $lagstring;
	} elsif( $lag < 60*60 ) {
		$lagstring = sprintf "%d minute%s%s", int($lag/60), int($lag/60) == 1 ? '' : 's', $lagstring;
	} elsif( $lag < 60*60*5 ) {
		$lagstring = sprintf "%d hour%s and %d minute%s%s", int($lag/60/60), int($lag/60/60) == 1 ? '' : 's', ($lag/60%60), $lag/60%60 == 1 ? '' : 's', $lagstring;
	} elsif( $lag < 60*60*24 ) {
		$lagstring = sprintf "%d hour%s%s", int($lag/60/60), int($lag/60/60) == 1 ? '' : 's', $lagstring;
	} elsif( $lag < 60*60*24*3 ) {
		$lagstring = sprintf "%d day%s and %d hour%s%s", int($lag/60/60/24), int($lag/60/60/24) == 1 ? '' : 's', $lag/60/60%24, $lag/60/60%24 == 1 ? '' : 's', $lagstring;
	} else {
		$lagstring = sprintf "%d day%s%s", int($lag/60/60/24), int($lag/60/60/24) == 1 ? '' : 's', $lagstring;
	}
	
	return $lagstring;
}

# For File::Find later
my @dataxmls;
sub wantedDataXML {
    if( -f $_ && ( $File::Find::name =~ /\/sws-[0-9]+\/data.xml$/ || $File::Find::name =~ /\/sws-[\w]+-[0-9]+\/data.xml$/ ) ) {
        push @dataxmls, $File::Find::name;
    }
}

## CODE ##

# Get the action first.
usage(0) unless @ARGV;
my $action = lc shift @ARGV;
usage(0) if $action eq "-h" || $action eq "help" || $action eq "-help" || $action eq "--help";

# Get options.
my $rc = GetOptions(
    "version=s"     => \$opt_version,
    "logger=s"      => \$opt_logger,
    "file=s"        => \$opt_file,
    "dir=s"         => \$opt_dir,
    "minlength=i"   => \$opt_minlength,
    "attempts"      => \$opt_attempts,
    "nowrite"       => \$opt_nowrite,
    "year=i"        => \$opt_year,
    "sfile=s"       => \$opt_sfile,
    "trash"         => \$opt_trash,
    "overall"       => \$opt_overall,
    "combine"       => \$opt_combine,
    "server=s"      => \$opt_server,
    "collapse"      => \$opt_collapse,
    "tail"          => \$opt_tail,
    "meta"          => \$opt_meta,
);

# Clean up opt_dir
if( $opt_dir ) {
    $opt_dir = File::Spec->rel2abs($opt_dir);
}

# Create a parser.
my $parser = Stasis::Parser->new( ref => 1, version => $opt_version, logger => $opt_logger, year => $opt_year );

# Set encoding of STDOUT to UTF-8 (which Blizzard uses for combat logs)
binmode(STDOUT, ":utf8");

# Case out the various actions.
if( $action eq "print" ) {
    # action PRINT: used to print out actions from a log file
    
    # Figure out what input to use.
    my $db;
    my $fh;
    
    if( $opt_file ) {
        # Get a filehandle.
        
        if( $opt_tail ) {
            # See if we have File::Tail
            eval {
                require File::Tail;
                import File::Tail;
            }; if( $@ ) {
                bomb "please install File::Tail from CPAN or try again without -tail";
            }
            
            tie *TAILFH, "File::Tail", ( 
                name => $opt_file,

                # Never wait more than 1 second between checks.
                maxinterval => 1,

                # Tail from the end of the file, don't read in pre-existing data.
                tail => 0,

                # If the file is moved out of the way and replaced, read its entire replacement.
                reset_tail => 1,
            );
            
            $fh = \*TAILFH;
            status "WARNING: -tail is an experimental option, please report any strange behavior";
        } else {
            open $fh, $opt_file or bomb "could not open file: $opt_file";
        }
    } elsif( $opt_sfile ) {
        # Get a database connection.
        
        if( $opt_tail ) {
            bomb "SQLite mode is not supported with -tail.";
        } else {
            status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
            $db = Stasis::DB->new( db => $opt_sfile );
            $db->line(1);
        }
    } else {
        $opt_file = 1;
        $fh = \*STDIN;
    }
    
    while( defined( $_ = $opt_file ? <$fh> : $db->line() ) ) {
        # Because File::Tail screws up Unicode
        utf8::decode($_) if $opt_tail;
        
        my $pline = $opt_file ? $parser->parse( $_ ) : $_;
        if( $pline->{action} ) {
            if( my $text = $parser->toString( $pline ) ) {
                $pline->{t} =~ /^(\d+)(\.(\d+)|)$/;
                my @t = localtime $1;
                printf "%d/%d %02d:%02d:%02d\.%03d  %s\n", $t[4]+1, $t[3], $t[2], $t[1], $t[0], $2?$3:0, $text;
            }
        }
    }
} elsif( $action eq "add" ) {
    # Figure out what input to use.
    my $fh;
    my $db;
    
    if( $opt_file ) {
        # Get a filehandle.
        
        if( $opt_tail ) {
            # See if we have File::Tail
            eval {
                require File::Tail;
                import File::Tail;
            }; if( $@ ) {
                bomb "please install File::Tail from CPAN or try again without -tail";
            }
            
            # Can't do trash, combine, or overall with -tail
            if( $opt_trash || $opt_combine || $opt_overall ) {
                bomb "-trash, -combine, and -overall are not supported with -tail"
            }
            
            tie *TAILFH, "File::Tail", ( 
                name => $opt_file,

                # Never wait more than 1 second between checks.
                interval => 1,
                maxinterval => 1,

                # Tail from the end of the file, don't read in pre-existing data.
                tail => 0,

                # If the file is moved out of the way and replaced, read its entire replacement.
                reset_tail => 1,
            );
            
            $fh = \*TAILFH;
            status "WARNING: -tail is an experimental option, please report any strange behavior";
        } else {
            open $fh, $opt_file or bomb "could not open file: $opt_file";
        }
    } elsif( $opt_sfile ) {
        # Get a database connection.
        
        if( $opt_tail ) {
            bomb "SQLite mode is not supported with -tail";
        } else {
            status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
            $db = Stasis::DB->new( db => $opt_sfile );
            $db->line(1);
        }
    } else {
        $opt_file = 1;
        $fh = \*STDIN;
    }
    
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Set up the event dispatchers.
    my $ed_splitter = Stasis::EventDispatcher->new;
    my $ed = Stasis::EventDispatcher->new;
    
    # Assign classes to %raid and splits to @splits
    my %boss_tries;
    
    # Holds "-trash" extensions.
    my $trash_exts = makeext;
    
    # Holds "-overall" extensions.
    my $overall_exts = makeext;
    
    # Holds extensions for the current boss.
    my $split_exts = makeext;
    
    # Holds "-combine" extensions.
    my %combine_exts;
    
    my $classer = Stasis::ClassGuess->new( version => $opt_version );
    my $splitter = Stasis::LogSplit->new( version => $opt_version, callback =>
        # LogSplit callback
        sub {
            my ($short, $start, $long, $kill, $end) = @_;
            if( ! defined $kill ) {
                # Starting a new split.
                $split_exts->start($ed);
                
                # Start up the combined extensions.
                if( $opt_combine ) {
                    if( !$combine_exts{ $short } ) {
                        $combine_exts{ $short } = makeext;
                        $combine_exts{ $short }->start($ed);
                    } else {
                        $combine_exts{ $short }->resume($ed);
                    }
                }
                
                # Suspend trash.
                $trash_exts->suspend($ed) if $opt_trash;
                
                # Let the user know we saw a boss start.
                $start =~ /^(\d+)(\.(\d+)|)$/;
                my @t = localtime $1;
                status sprintf(
                    "Encounter start: %s at %d/%d %02d:%02d:%02d\.%03d%s .. ",
                    $short,
                    $t[4]+1,
                    $t[3],
                    $t[2],
                    $t[1],
                    $t[0],
                    $2?$3:0,
                    $opt_tail ? " (" . lagstring(time-int($start)) . ")" : "",
                );
            } else {
                # Closing a split.
                $split_exts->finish($ed);
                $boss_tries{ $short } ++;
                
                # Suspend the combined extensions.
                $combine_exts{ $short }->suspend($ed) if $opt_combine;
                
                # Resume trash.
                $trash_exts->resume($ed) if $opt_trash;
                
                # Possibly add an attempt number
                $long .= " try " . $boss_tries{ $short } if !$kill;
                
                if( $opt_minlength && $end - $start < $opt_minlength ) {
                    # Check minlength option.
                    status "skipping (too short).";
                } elsif( !$opt_attempts && !$kill ) {
                    # Check attempts option.
                    status "skipping (not a kill).";
                } else {
                    # If we got this far, we should write this encounter.
                    # Get whatever the class guesser has figured out by now.
                    my %raid = $classer->finish;
                    
                    status sprintf "writing %s (sws-%s-%d) .. ", $long, $short, floor($start);

                    # Find the directory name.
                    my $dname = sprintf "%s/sws-%s-%d", $opt_dir, $short, floor($start);
                    my $dname_old = sprintf "%s/sws-%d", $opt_dir, floor($start);

                    # Write the files for this split.
                    unless( $opt_nowrite ) {
                        eval {
                            writedir $dname, $dname_old, $long, $short, \%raid, $split_exts, $opt_collapse;
                        }; if( $@ ) {
                            bomb $@;
                        }
                    }

                    status "done.";
                }
            }
        }
    );
    
    # Add LogSplit and ClassGuess to the event dispatcher.
    $ed->add( $classer );
    $ed_splitter->add( $splitter );
    
    # Start overall and trash if requested.
    $overall_exts->start($ed) if $opt_overall;
    $trash_exts->start($ed) if $opt_trash;
    
    # Keep track of when the log started.
    my $first = 0;
    
    while( defined( $_ = $opt_file ? <$fh> : $db->line() ) ) {
        # Because File::Tail screws up Unicode
        utf8::decode($_) if $opt_tail;
        
        # Get the line.
        my $pline = $opt_file ? $parser->parse($_) : $_;
        $first ||= $pline->{t};
        
        # Dispatch this action.
        if( $Stasis::Parser::action_map{ $pline->{action} } ) {
            $ed_splitter->process($pline);
            $ed->process($pline);
        } else {
            warn "Unrecognized action: " . ($pline->{action} || "[undefined]");
        }
    }
    
    if( $opt_tail ) {
        # Shouldn't do any of this other junk.
        status "Ending.";
        exit(0);
    }
    
    if( $opt_combine ) {
        foreach my $e (values %combine_exts) {
            $e->finish($ed);
        }
    }
    
    if( $opt_trash ) {
        $trash_exts->finish($ed);
    }
    
    if( $opt_overall ) {
        $overall_exts->finish($ed);
    }
    
    my %raid = $classer->finish;
    my @splits = $splitter->finish;
    
    # Remove these tools.
    undef $classer;
    undef $splitter;
    
    # Close the file.
    if( $opt_file ) {
        close $fh;
    } else {
        $db->disconnect();
    }
    
    # Count the results so the user can see what's up.
    my $n_players = 0;
    my $n_pets = 0;
    while( my ($rid, $rdata) = each(%raid) ) {
        if( $rdata->{class} ne "Pet" ) {
            $n_players ++;
        } else {
            $n_pets ++;
        }
    }
    
    status 
            "Done processing. Found $n_players player" . ($n_players == 1 ? "" : "s") . 
            ", $n_pets pet" . ($n_pets == 1 ? "" : "s") . 
            ", and " . scalar(@splits) . " boss encounter" . (scalar(@splits) == 1 ? "" : "s") . ".";
    
    # Write trash
    if( $opt_trash && !$opt_nowrite ) {
        my $dname = sprintf "%s/sws-trash-%d", $opt_dir, floor($first);
        my $dname_old = $dname;
        status sprintf "Writing Trash Mobs (sws-trash-%d) .. ", floor($first);
        
        eval {
            writedir $dname, $dname_old, "Trash Mobs", "trash", \%raid, $trash_exts, 1;
            status "done.";
        }; if( $@ ) {
            bomb $@;
        }
    }
    
    # Write combine
    if( $opt_combine && !$opt_nowrite ) {
        while( my ($kboss, $exts) = each (%combine_exts) ) {
            my $dname = sprintf "%s/sws-%s-combine-%d", $opt_dir, $kboss, floor($first);
            my $dname_old = $dname;
            
            # Skip unless we actually had more than one of this boss.
            if( $boss_tries{$kboss} > 1 ) {
                # Boss name.
                my $bname = Stasis::LogSplit->name( $kboss );
            
                status sprintf "Writing $bname (combined) (sws-%s-combine-%d) .. ", $kboss, floor($first);
                eval {
                    writedir $dname, $dname_old, "$bname (combined)", $kboss . "-combine", \%raid, $exts, $opt_collapse;
                }; if( $@ ) {
                    bomb $@;
                }
                
                status "done.";
            }
        }
    }
    
    # Write overall
    if( $opt_overall && !$opt_nowrite ) {
        my $dname = sprintf "%s/sws-overall-%d", $opt_dir, floor($first);
        my $dname_old = $dname;
        status sprintf "Writing Overall (sws-overall-%d) .. ", floor($first);
        
        eval {
            writedir $dname, $dname_old, "Overall", "overall", \%raid, $overall_exts, 1;
        }; if( $@ ) {
            bomb $@;
        }
        
        status "done.";
    }
} elsif( $action eq "history" ) {
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Header
    my $xml = "<wws-history>\n";
    
    # Look at all data.xmls.
    @dataxmls = ();
    File::Find::find( \&wantedDataXML, ($opt_dir) );
    
    status "Reading from " . (scalar @dataxmls) . " subdirectories.";
    
    foreach my $dataxml (@dataxmls) {
        open DXML, $dataxml or die "Could not open a subdirectory for reading.";
        while( <DXML> ) {
            $xml .= $_;
        }
        close DXML;
    }
    
    # Footer
    $xml .= "</wws-history>\n";
    
    # Create wws-history directory if it doesn't exist.
    if( ! -d $opt_dir . "/wws-history" ) {
        mkdir $opt_dir . "/wws-history" or bomb "Could not create extras directory";
    }
    
    open DXML, ">$opt_dir/wws-history/data.xml" or die "Could not open data.xml for writing";
    print DXML $xml;
    close DXML;
    
    status "Wrote: $opt_dir/wws-history/data.xml";
    
    # Copy JS and CSS
    my ($prog_vol, $prog_dir) = File::Spec->splitpath( File::Spec->rel2abs($0) );
    my $extra_path = File::Spec->catpath( $prog_vol, File::Spec->catdir( $prog_dir, "extras" ), "" );
    
    if( -d $extra_path && -f "$extra_path/sws.js" && -f "$extra_path/sws2.css" ) {
        status "Copying extras from: $extra_path";
        
        # Create extras directory if it doesn't exist
        if( ! -d $opt_dir . "/extras" ) {
            mkdir $opt_dir . "/extras" or die;
        }
        
        # Copy JS and CSS
        copy( "$extra_path/sws.js", "$opt_dir/extras/sws.js" ) or die;
        status "Wrote: $opt_dir/extras/sws.js";
        
        copy( "$extra_path/sws2.css", "$opt_dir/extras/sws2.css" ) or die;
        status "Wrote: $opt_dir/extras/sws2.css";
    } else {
        bomb "Could not find extras dir: checked $extra_path";
    }
} elsif( $action eq "convert" ) {
    status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
    
    # Figure out the filehandle to use.
    my $fh;
    if( $opt_file ) {
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } else {
        $opt_file = 1;
        $fh = \*STDIN;
    }
    
    if( $opt_tail ) {
        bomb "tail is not supported in SQLite mode, try again without -tail";
    }
    
    # Get a database connection.
    my $db = Stasis::DB->new( db => $opt_sfile );
    
    if( -e $opt_sfile ) {
        # Bail if the file exists.
        bomb "target file exists, choose another name: $opt_sfile";
    }
    
    eval {
        # Create the target file.
        $db->create();
        
        # Import log entries.
        my $nlog = -1;
        while( <$fh> ) {
            $nlog++;
            my $entry = $parser->parse($_);
            $db->addLine( $nlog, $entry );
        }
        
        $db->finish();
        $db->disconnect();
    }; if( $@ ) {
        bomb "convert error: $@";
        unlink $opt_sfile;
    }
} else {
    bomb "bad action: $action";
}

exit 0;
