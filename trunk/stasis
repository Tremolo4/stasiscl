#!/usr/bin/perl -w

# Copyright (c) 2008, Gian Merlino
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;
use lib 'lib';
use open ':encoding(utf8)';
use Stasis::Parser;
use Stasis::LogSplit;
use Stasis::ClassGuess;
use Stasis::Extension;
use Stasis::ChartPage;
use Stasis::ActorPage;
use Stasis::SpellPage;
use Stasis::ActorGroup;
use Stasis::PageMaker;
use Stasis::DB;
use File::Find qw();
use File::Path qw();
use File::Spec qw();
use File::Copy qw(copy);
use POSIX;
use HTML::Entities;
use Getopt::Long;

## OPTIONS ##
my $opt_version = 2;
my $opt_minlength = 30;
my $opt_sfile;
my $opt_dir = ".";
my $opt_nowrite;
my $opt_logger;
my $opt_file;
my $opt_attempts;
my $opt_year;
my $opt_trash;
my $opt_overall;
my $opt_server;

## SUBS ##

sub usage {
    my ($exitvalue) = @_;
    $exitvalue ||= 1;

    my $me = $0;
    $me =~ s/^.*\///;
    print STDERR <<USAGE;
Usage:
    $me action [options]

There are 2 main actions:
    history    Updates the wws-history/data.xml in the specified
               directory with all accumulated data of all sws-* dirs.

    add        Read a combat log and write out parsed HTML corresponding
               to the encounters found within in.

Options:
    -file      Specifies the combat log to read.

    -dir       Specifies in which directory the generated HTML is living
               or will be written, depending on action. Default is the
               current directory.

    -version   Either 1 or 2. Pre-2.4 combatlogs should be parsed with
               version = 1, post-2.4 combatlogs with 2. Default is '2',
               the new post-2.4 style.

    -logger    Name of the logger, optional argument only used when parsing
               version 1 combat logs. Default is 'You'.

    -minlength Exclude encounters less than this amount of seconds in length.
               Defaults to 30 seconds.
               
    -attempts  Include a parse for boss attempts (not just kills).
                   
    -trash     Include a parse for trash mobs (all sections of the log that
               were not part of a boss encounter).
               
    -overall   Include a separate parse that rolls up everything else that 
               was parsed. For example, if this option is specified alone
               (without -trash or -attempt) this will include a parse that
               rolls up all boss kills. If you specify -attempt and -overall
               but not -trash, this will include a parse that rolls up all
               boss kills and attempts. If you specify -trash, -attempt, 
               and -overall this will include a parse that rolls up every
               action in the log file.

Example for parsing boss kills only:
    $me add -dir /var/www/sws -file WoWCombatLog.txt

Example for parsing every single line in a log:
    $me add -dir /var/www/sws -file WoWCombatLog.txt -attempt -trash -overall

Example for updating the wws-history/data.xml:
    $me history -dir /var/www/swstats.domain.com

USAGE
    exit $exitvalue;
}

sub bomb($) {
    my $msg = shift;
    my $prog = $0;
    $msg =~ s/^/$prog: /gm;
    chomp $msg;
    print STDERR $msg . "\n";
    exit 1;
}

sub status($) {
    my $msg = shift;
    my $prog = $0;
    
    if( $msg !~ /^[a-z]/ ) {
        $msg =~ s/^/$prog: /gm;
    }
    
    chomp $msg;
    if( $msg =~ /\.\.\s*$/ ) {
        print STDERR $msg;
    } else {
        print STDERR $msg . "\n";
    }
}

sub writedir($$$$$$$) {
    my ($dname, $dname_old, $long, $short, $raid, $exts, $collapse) = @_;
    
    # Remove the directory if it exists.
    File::Path::rmtree($dname) if -d $dname;
    File::Path::rmtree($dname_old) if -d $dname_old;

    # Create the directory.
    mkdir $dname or die $!;

    # Write the index.
    my $charter = Stasis::ChartPage->new( name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    my ($chart_xml, $chart_html) = $charter->page;
    open CHARTPAGE, ">$dname/index.html" or die;
    print CHARTPAGE $chart_html;
    close CHARTPAGE;
    
    # Group actors.
    my $grouper = Stasis::ActorGroup->new;
    $grouper->run( $raid, $exts );

    # Write the actor files.
    my $ap = Stasis::ActorPage->new( server => $opt_server, name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    foreach my $actor (keys %{$exts->{Presence}{actors}}) {
        # Respect $collapse.
        next if $collapse && $grouper->group($actor);
        
        my $id = lc $actor;
        $id = Stasis::PageMaker->tameText($id);

        open ACTORPAGE, sprintf ">$dname/actor_%s.html", $id or die;
        print ACTORPAGE $ap->page($actor);
        close ACTORPAGE;
    }
    
    # Write the group files.
    foreach my $group (@{$grouper->{groups}}) {
        my $id = lc $grouper->captain($group);
        $id = Stasis::PageMaker->tameText($id);
        
        open GROUPPAGE, sprintf ">$dname/group_%s.html", $id or die;
        print GROUPPAGE $ap->page($grouper->captain($group), 1);
        close GROUPPAGE;
    }
    
    # Write the environment file.
    open ENVPAGE, ">$dname/actor_0.html" or die;
    print ENVPAGE $ap->page(0);
    close ENVPAGE;
    
    # Write the spell files.
    my $sp = Stasis::SpellPage->new( name => $long, short => $short, raid => $raid, ext => $exts, collapse => $collapse );
    foreach my $spell (keys %{$exts->{Index}{spells}}) {
        my $id = lc $spell;
        $id = Stasis::PageMaker->tameText($id);

        open SPELLPAGE, sprintf ">$dname/spell_%s.html", $id or die;
        print SPELLPAGE $sp->page($spell);
        close SPELLPAGE;
    }

    # Write the data.xml file.
    open DATAXML, ">$dname/data.xml" or die;
    print DATAXML $chart_xml;
    close DATAXML;
}

# For File::Find later
my @dataxmls;
sub wantedDataXML {
    if( -f $_ && ( $File::Find::name =~ /\/sws-[0-9]+\/data.xml$/ || $File::Find::name =~ /\/sws-[\w]+-[0-9]+\/data.xml$/ ) ) {
        push @dataxmls, $File::Find::name;
    }
}

## CODE ##

# Get the action first.
usage(0) unless @ARGV;
my $action = lc shift @ARGV;
usage(0) if $action eq "-h" || $action eq "help" || $action eq "-help" || $action eq "--help";

# Get options.
my $rc = GetOptions(
    "version=s"     => \$opt_version,
    "logger=s"      => \$opt_logger,
    "file=s"        => \$opt_file,
    "dir=s"         => \$opt_dir,
    "minlength=i"   => \$opt_minlength,
    "attempts"      => \$opt_attempts,
    "nowrite"       => \$opt_nowrite,
    "year=i"        => \$opt_year,
    "sfile=s"       => \$opt_sfile,
    "trash"         => \$opt_trash,
    "overall"       => \$opt_overall,
    "server=s"      => \$opt_server,
);

# Clean up opt_dir
if( $opt_dir ) {
    $opt_dir = File::Spec->rel2abs($opt_dir);
}

# Create a parser.
my $parser = Stasis::Parser->new( ref => 1, version => $opt_version, logger => $opt_logger, year => $opt_year );

# Set encoding of STDOUT to UTF-8 (which Blizzard uses for combat logs)
binmode(STDOUT, ":utf8");

# Case out the various actions.
if( $action eq "print" ) {
    # action PRINT: used to print out actions from a log file
    
    # Figure out what input to use.
    my $db;
    my $fh;
    
    if( $opt_file ) {
        # Get a filehandle.
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } elsif( $opt_sfile ) {
        # Get a database connection.
        status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
        $db = Stasis::DB->new( db => $opt_sfile );
        $db->line(1);
    } else {
        bomb "STDIN is no longer supported, please use -file or -sfile (see 'stasis help' for more details)";
    }
    
    while( defined( $_ = $opt_file ? <$fh> : $db->line() ) ) {
        my $entry = $opt_file ? $parser->parse($_) : $_;
        if( $entry->{action} ) {
            if( my $text = $parser->toString( $entry ) ) {
                $entry->{t} =~ /^(\d+)(\.(\d+)|)$/;
                my @t = localtime $1;
                printf "%d/%d %02d:%02d:%02d\.%03d  %s\n", $t[4]+1, $t[3], $t[2], $t[1], $t[0], $2?$3:0, $text;
            }
        }
    }
} elsif( $action eq "add" ) {
    # Figure out what input to use.
    my $fh;
    my $db;
    
    if( $opt_file ) {
        # Get a filehandle.
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } elsif( $opt_sfile ) {
        # Get a database connection.
        status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
        $db = Stasis::DB->new( db => $opt_sfile );
        $db->line(1);
    } else {
        bomb "STDIN is no longer supported, please use -file or -sfile (see 'stasis help' for more details)";
    }
    
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Assign classes to %raid and splits to @splits
    status "Assigning classes and splitting bosses .. ";
    
    my $classer = Stasis::ClassGuess->new( version => $opt_version );
    my $splitter = Stasis::LogSplit->new( version => $opt_version );
    
    while( defined( $_ = $opt_file ? <$fh> : $db->line() ) ) {
        my $pline = $opt_file ? $parser->parse($_) : $_;
        $classer->process($pline);
        $splitter->process($pline);
    }
    
    my %raid = $classer->finish();
    my @splits = $splitter->finish();
    
    # Remove these tools.
    undef $classer;
    undef $splitter;
    
    # Count the results so the user can see what's up.
    my $n_players = 0;
    my $n_pets = 0;
    while( my ($rid, $rdata) = each(%raid) ) {
        if( $rdata->{class} ne "Pet" ) {
            $n_players ++;
        } else {
            $n_pets ++;
        }
    }
    
    status 
            "found $n_players player" . ($n_players == 1 ? "" : "s") . 
            ", $n_pets pet" . ($n_pets == 1 ? "" : "s") . 
            ", and " . scalar(@splits) . " boss encounter" . (scalar(@splits) == 1 ? "" : "s") . ".";
    
    # Create extensions.
    my @ext_names = qw(Activity Damage Death Healing Aura Cast ExtraAttack Interrupt Power Presence Index);
    my %exts;
    foreach (@ext_names) {
        $exts{$_} = Stasis::Extension->factory($_);
    }
    
    # We need separate extensions for the trash and overall parses.
    my %trash_exts;
    if( $opt_trash ) {
        foreach (@ext_names) {
            $trash_exts{$_} = Stasis::Extension->factory($_);
            $trash_exts{$_}->start();
        }
    }
    
    my %overall_exts;
    if( $opt_overall ) {
        foreach (@ext_names) {
            $overall_exts{$_} = Stasis::Extension->factory($_);
            $overall_exts{$_}->start();
        }
    }
    
    # Rewind the file.
    if( $opt_file ) {
        seek $fh, 0, 0;
    } else {
        $db->line(1);
    }
    
    # Keep track of when this log file started.
    my $first = 0;
    
    # Keep track of what line we're on.
    my $nlog = -1;
    
    # First split.
    my $split = shift @splits;
    
    # Process the file.
    my $pline;
    while( defined( my $line = $opt_file ? <$fh> : $db->line() ) ) {
        if( !$first ) {
            $pline = $opt_file ? $parser->parse($line) : $line;
            $first = $pline->{t};
        }
        
        # Log lines are indexed starting from zero.
        $nlog ++;
        
        if( $split && $nlog >= $split->{startLine} ) {
            # We're inside $split.
            
            if( $opt_minlength && $split->{end} - $split->{start} < $opt_minlength ) {
                # Check minlength option.
                status sprintf "Skipping: %s (too short).", $split->{long} if $nlog == $split->{startLine};
            } elsif( !$opt_attempts && !$split->{kill} ) {
                # Check attempts option.
                status sprintf "Skipping: %s (not a kill).", $split->{long}, $split->{end} - $split->{start} if $nlog == $split->{startLine};
            } else {
                # If we got this far, we should parse this encounter.
                $pline = $opt_file ? $parser->parse($line) : $line;

                # If this is the first line, start all the extensions.
                if( $nlog == $split->{startLine} ) {
                    foreach my $ext (values %exts) {
                        $ext->start();
                    }
                }

                # Run this line through the extensions.
                foreach my $ext (values %exts) {
                    $ext->process($pline);
                }

                foreach my $overall_ext (values %overall_exts) {
                    $overall_ext->process($pline);
                }

                # When we reach the last line, write this split out.
                if( $split && $nlog >= $split->{endLine} ) {
                    # Find the directory name.
                    my $dname = sprintf "%s/sws-%s-%d", $opt_dir, $split->{short}, floor($split->{start});
                    my $dname_old = sprintf "%s/sws-%d", $opt_dir, floor($split->{start});

                    # End all the extensions.
                    foreach my $ext (values %exts) {
                        $ext->finish();
                    }

                    # Write the files for this split.
                    unless( $opt_nowrite ) {
                        eval {
                            writedir $dname, $dname_old, $split->{long}, $split->{short}, \%raid, \%exts, 0;
                        }; if( $@ ) {
                            bomb $@;
                        }
                    }

                    status sprintf "Wrote: %s (sws-%s-%d).", $split->{long}, $split->{short}, floor($split->{start});
                }
            }
        } elsif( $opt_trash ) {
            # We haven't yet reached $split, or we're past the last one.
            $pline = $opt_file ? $parser->parse($line) : $line;
            
            foreach my $trash_ext (values %trash_exts) {
                $trash_ext->process($pline);
            }
            
            foreach my $overall_ext (values %overall_exts) {
                $overall_ext->process($pline);
            }
        }
        
        # When we reach the last line, move to the next split.
        if( $split && $nlog >= $split->{endLine} ) {
            $split = shift @splits;
        }
    }
    
    # Close the file.
    if( $opt_file ) {
        close $fh;
    } else {
        $db->disconnect();
    }
    
    # Write the files for the trash extensions.
    if( $opt_trash ) {
        my $dname = sprintf "%s/sws-trash-%d", $opt_dir, floor($first);
        my $dname_old = $dname;
        
        foreach my $ext (values %trash_exts) {
            $ext->finish();
        }
        
        unless( $opt_nowrite ) {
            eval {
                writedir $dname, $dname_old, "Trash Mobs", "trash", \%raid, \%trash_exts, 1;
            }; if( $@ ) {
                bomb $@;
            }
        }
        
        status sprintf "Wrote: Trash Mobs (sws-trash-%d).", floor($first);
    }
    
    # Write the files for the overall extensions.
    if( $opt_overall ) {
        my $dname = sprintf "%s/sws-overall-%d", $opt_dir, floor($first);
        my $dname_old = $dname;
        
        foreach my $ext (values %overall_exts) {
            $ext->finish();
        }
        
        unless( $opt_nowrite ) {
            eval {
                writedir $dname, $dname_old, "Overall", "overall", \%raid, \%overall_exts, 1;
            }; if( $@ ) {
                bomb $@;
            }
        }
        
        status sprintf "Wrote: Overall (sws-overall-%d).", floor($first);
    }
} elsif( $action eq "history" ) {
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Header
    my $xml = "<wws-history>\n";
    
    # Look at all data.xmls.
    @dataxmls = ();
    File::Find::find( \&wantedDataXML, ($opt_dir) );
    
    status "Reading from " . (scalar @dataxmls) . " subdirectories.";
    
    foreach my $dataxml (@dataxmls) {
        open DXML, $dataxml or die "Could not open a subdirectory for reading.";
        while( <DXML> ) {
            $xml .= $_;
        }
        close DXML;
    }
    
    # Footer
    $xml .= "</wws-history>\n";
    
    # Create wws-history directory if it doesn't exist.
    if( ! -d $opt_dir . "/wws-history" ) {
        mkdir $opt_dir . "/wws-history" or bomb "Could not create extras directory";
    }
    
    open DXML, ">$opt_dir/wws-history/data.xml" or die "Could not open data.xml for writing";
    print DXML $xml;
    close DXML;
    
    status "Wrote: $opt_dir/wws-history/data.xml";
    
    # Copy JS and CSS
    my $prog = $0;
    $prog =~ s/\/[^\/]*$//;
    my $extra_path = File::Spec->catdir( File::Spec->rel2abs($prog), "extras" );
    
    if( -d $extra_path && -f "$extra_path/sws.js" && -f "$extra_path/sws2.css" ) {
        status "Copying extras from: $extra_path";
        
        # Create extras directory if it doesn't exist
        if( ! -d $opt_dir . "/extras" ) {
            mkdir $opt_dir . "/extras" or die;
        }
        
        # Copy JS and CSS
        copy( "$extra_path/sws.js", "$opt_dir/extras/sws.js" ) or die;
        status "Wrote: $opt_dir/extras/sws.js";
        
        copy( "$extra_path/sws2.css", "$opt_dir/extras/sws2.css" ) or die;
        status "Wrote: $opt_dir/extras/sws2.css";
    } else {
        bomb "Could not find extras dir: checked $extra_path";
    }
} elsif( $action eq "convert" ) {
    status "WARNING: SQLite mode is experimental, and the file format is subject to change!";
    
    # Figure out the filehandle to use.
    my $fh;
    if( $opt_file ) {
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } else {
        bomb "STDIN is no longer supported, please use -file (see 'stasis help' for more details)";
    }
    
    # Get a database connection.
    my $db = Stasis::DB->new( db => $opt_sfile );
    
    if( -e $opt_sfile ) {
        # Bail if the file exists.
        bomb "target file exists, choose another name: $opt_sfile";
    }
    
    eval {
        # Create the target file.
        $db->create();
        
        # Import log entries.
        my $nlog = -1;
        while( <$fh> ) {
            $nlog++;
            my $entry = $parser->parse($_);
            $db->addLine( $nlog, $entry );
        }
        
        $db->finish();
        $db->disconnect();
    }; if( $@ ) {
        bomb "convert error: $@";
        unlink $opt_sfile;
    }
} else {
    bomb "bad action: $action";
}

exit 0;
