#!/usr/bin/perl -w

# Copyright (c) 2008, Gian Merlino
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;
use lib 'lib';
use open ':encoding(utf8)';
use Stasis::Parser;
use Stasis::LogSplit;
use Stasis::ClassGuess;
use Stasis::Extension;
use Stasis::ActorPage;
use Stasis::ChartPage;
use Stasis::PageMaker;
use File::Find qw();
use File::Path qw();
use File::Spec qw();
use File::Copy qw(copy);
use POSIX;
use HTML::Entities;
use Getopt::Long;

## SUBS ##

sub usage {
    my ($exitvalue) = @_;
    $exitvalue ||= 1;

    my $me = $0;
    $me =~ s/^.*\///;
    print STDERR <<USAGE;
Usage:
    $me action [options]

There are 2 main actions:
    history    Updates the wws-history/data.xml in the specified
               directory with all accumulated data of all sws-* dirs.

    add        Read a combat log and write out parsed HTML corresponding
               to the encounters found within in.

Options:
    -file      Specifies the combat log to read.

    -dir       Specifies in which directory the generated HTML is living
               or will be written, depending on action. Default is the
               current directory.

    -version   Either 1 or 2. Pre-2.4 combatlogs should be parsed with
               version = 1, post-2.4 combatlogs with 2. Default is '2',
               the new post-2.4 style.

    -logger    Name of the logger, optional argument only used when parsing
               version 1 combat logs. Default is 'You'.

Example for parsing a new log:
    $me add -dir /var/www/swstats.domain.com -file WoWCombatLog.txt

Example for updating the wws-history/data.xml:
    $me history -dir /var/www/swstats.domain.com

USAGE
    exit $exitvalue;
}

sub bomb($) {
    my $msg = shift;
    my $prog = $0;
    $msg =~ s/^/$prog: /gm;
    chomp $msg;
    print STDERR $msg . "\n";
    exit 1;
}

sub status($) {
    my $msg = shift;
    my $prog = $0;
    
    if( $msg !~ /^[a-z]/ ) {
        $msg =~ s/^/$prog: /gm;
    }
    
    chomp $msg;
    if( $msg =~ /\.\.\s*$/ ) {
        print STDERR $msg;
    } else {
        print STDERR $msg . "\n";
    }
}

# For File::Find later
my @dataxmls;
sub wantedDataXML {
    if( -f $_ && ( $File::Find::name =~ /\/sws-[0-9]+\/data.xml$/ || $File::Find::name =~ /\/sws-[\w]+-[0-9]+\/data.xml$/ ) ) {
        push @dataxmls, $File::Find::name;
    }
}

## CODE ##

# Get the action first.
usage(0) unless @ARGV;
my $action = lc shift @ARGV;
usage(0) if $action eq "-h" || $action eq "help" || $action eq "-help" || $action eq "--help";

# Get options.
my $opt_version = 2;
my $opt_minlength = 30;
my $opt_db;
my $opt_dir = ".";
my $opt_nowrite;
my $opt_hintsfile;
my $opt_logger;
my $opt_file;
my $opt_attempts;
my $opt_year;

my $rc = GetOptions(
    "version=s"     => \$opt_version,
    "logger=s"      => \$opt_logger,
    #"hintsfile=s"   => \$opt_hintsfile,
    "file=s"        => \$opt_file,
    "dir=s"         => \$opt_dir,
    "minlength=i"   => \$opt_minlength,
    "attempts"      => \$opt_attempts,
    "nowrite"       => \$opt_nowrite,
    "year=i"        => \$opt_year,
    "db=s"          => \$opt_db,
);

# Clean up opt_dir
if( $opt_dir ) {
    $opt_dir = File::Spec->rel2abs($opt_dir);
}

# Create a parser.
my $parser = Stasis::Parser->new( version => $opt_version, logger => $opt_logger, year => $opt_year );

# Set encoding of STDOUT to UTF-8 (which Blizzard uses for combat logs)
binmode(STDOUT, ":utf8");

# Case out the various actions.
if( $action eq "print" ) {
    # Figure out the filehandle to use.
    my $fh;
    if( $opt_file ) {
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } else {
        bomb "STDIN is no longer supported, please use -file (see 'stasis help' for more details)";
    }
    
    # action PRINT: used to print out actions from a log file
    while( <$fh> ) {
        my %entry = $parser->parse($_);
        if( $entry{action} ) {
            my $text = $parser->toString( \%entry );
            print "$text\n" if $text;
        }
    }
} elsif( $action eq "add" ) {
    # Figure out the filehandle to use.
    my $fh;
    if( $opt_file ) {
        open $fh, $opt_file or bomb "could not open file: $opt_file";
    } else {
        bomb "STDIN is no longer supported, please use -file (see 'stasis help' for more details)";
    }
    
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Check if $opt_hints (hints file) exists
    bomb "not a file: $opt_hintsfile" if( $opt_hintsfile && ! -f $opt_hintsfile && ! -l $opt_hintsfile );
    
    # Assign classes to %raid and splits to @splits
    status "Assigning classes and splitting bosses .. ";
    
    my $classer = Stasis::ClassGuess->new( version => $opt_version, hintsfile => $opt_hintsfile );
    my $splitter = Stasis::LogSplit->new;
    
    while( defined( my $line = <$fh> ) ) {
        my %pline = $parser->parse($line);
        $classer->process(\%pline);
        $splitter->process(\%pline);
    }
    
    my %raid = $classer->finish();
    my @splits = $splitter->finish();
    
    # Remove these tools.
    undef $classer;
    undef $splitter;
    
    # Count the results so the user can see what's up.
    my $n_players = 0;
    my $n_pets = 0;
    while( my ($rid, $rdata) = each(%raid) ) {
        if( $rdata->{class} ne "Pet" ) {
            $n_players ++;
        } else {
            $n_pets ++;
        }
    }
    
    status 
            "found $n_players player" . ($n_players == 1 ? "" : "s") . 
            ", $n_pets pet" . ($n_pets == 1 ? "" : "s") . 
            ", and " . scalar(@splits) . " boss encounter" . (scalar(@splits) == 1 ? "" : "s") . ".";
    
    # Rewind the file.
    seek $fh, 0, 0;
    
    # Keep track of what line we're on.
    my $nlog = -1;
    
    # Create extensions.
    my @ext_names = qw(Activity Damage Death Healing Aura Cast ExtraAttack Interrupt Power Presence Index);
    my %exts;
    foreach (@ext_names) {
        $exts{$_} = Stasis::Extension->factory($_);
    }
    
    # Process the splits, one at a time.
    foreach my $split (@splits) {
        my $boss = $split->{long};
        
        # Check zero length.
        if( $split->{endLine} - $split->{startLine} <= 0 ) {
            status sprintf "Skipping: %s (zero length).", $boss;
            next;
        }
        
        # Check negative time.
        if( $split->{end} - $split->{start} <= 0 ) {
            status sprintf "Skipping: %s (zero length).", $boss;
            next;
        }
        
        # Check minlength option.
        if( $opt_minlength && $split->{end} - $split->{start} < $opt_minlength ) {
            status sprintf "Skipping: %s (too short).", $boss;
            next;
        }
        
        # Check attempts option.
        if( !$opt_attempts && !$split->{kill} ) {
            status sprintf "Skipping: %s (not a kill).", $boss, $split->{end} - $split->{start};
            next;
        }
        
        # Run statistics for this boss.
        my $dname = sprintf "%s/sws-%s-%d", $opt_dir, $split->{short}, floor($split->{start});
        my $dname_old = sprintf "%s/sws-%d", $opt_dir, floor($split->{start});
        status sprintf "Processing: %s (sws-%s-%d).", $boss, $split->{short}, floor($split->{start});
        
        # Start all the extensions.
        foreach my $ext (values %exts) {
            $ext->start();
        }
        
        # Process the file.
        while( defined( my $line = <$fh> ) ) {
            # Log lines are indexed starting from zero.
            $nlog ++;
            
            # Seek to the first line.
            if( $nlog >= $split->{startLine} ) {
                my %pline = $parser->parse($line);
                
                foreach my $ext (values %exts) {
                    $ext->process(\%pline);
                }
            }
            
            # Stop at the last line.
            if( $nlog >= $split->{endLine} ) {
                last;
            }
        }
        
        # End all the extensions.
        foreach my $ext (values %exts) {
            $ext->finish();
        }
        
        # Write the files.
        unless( $opt_nowrite ) {
            eval {
                # Remove the directory if it exists.
                File::Path::rmtree($dname) if -d $dname;
                File::Path::rmtree($dname_old) if -d $dname_old;

                # Create the directory.
                mkdir $dname or die $!;

                # Write the index.
                my $charter = Stasis::ChartPage->new( name => $boss, short => $split->{short}, raid => \%raid, ext => \%exts );
                my ($chart_xml, $chart_html) = $charter->page;
                open CHARTPAGE, ">$dname/index.html" or die;
                print CHARTPAGE $chart_html;
                close CHARTPAGE;

                # Write the actor files.
                my $ap = Stasis::ActorPage->new( name => $boss, short => $split->{short}, raid => \%raid, ext => \%exts );
                foreach my $actor (keys %{$exts{Presence}{actors}}) {
                    my $id = lc $actor;
                    $id = Stasis::PageMaker->tameText($id);

                    open ACTORPAGE, sprintf ">$dname/actor_%s.html", $id or die;
                    print ACTORPAGE $ap->page($actor);
                    close ACTORPAGE;
                }

                # Write the data.xml file.
                open DATAXML, ">$dname/data.xml" or die;
                print DATAXML $chart_xml;
                close DATAXML;
            }; if( $@ ) {
                bomb $@;
            }
        }
    }
    
    # Close the file.
    if( $opt_file ) {
        close $fh;
    }
} elsif( $action eq "history" ) {
    # Going to output in $opt_dir
    bomb "not a directory: $opt_dir" unless $opt_dir && -d $opt_dir;
    status "Using directory: $opt_dir";
    
    # Header
    my $xml = "<wws-history>\n";
    
    # Look at all data.xmls.
    @dataxmls = ();
    File::Find::find( \&wantedDataXML, ($opt_dir) );
    
    status "Reading from " . (scalar @dataxmls) . " subdirectories.";
    
    foreach my $dataxml (@dataxmls) {
        open DXML, $dataxml or die "Could not open a subdirectory for reading.";
        while( <DXML> ) {
            $xml .= $_;
        }
        close DXML;
    }
    
    # Footer
    $xml .= "</wws-history>\n";
    
    # Create wws-history directory if it doesn't exist.
    if( ! -d $opt_dir . "/wws-history" ) {
        mkdir $opt_dir . "/wws-history" or bomb "Could not create extras directory";
    }
    
    open DXML, ">$opt_dir/wws-history/data.xml" or die "Could not open data.xml for writing";
    print DXML $xml;
    close DXML;
    
    status "Wrote: $opt_dir/wws-history/data.xml";
    
    # Copy JS and CSS
    my $prog = $0;
    $prog =~ s/\/[^\/]*$//;
    my $extra_path = File::Spec->catdir( File::Spec->rel2abs($prog), "extras" );
    
    if( -d $extra_path && -f "$extra_path/sws.js" && -f "$extra_path/sws2.css" ) {
        status "Copying extras from: $extra_path";
        
        # Create extras directory if it doesn't exist
        if( ! -d $opt_dir . "/extras" ) {
            mkdir $opt_dir . "/extras" or die;
        }
        
        # Copy JS and CSS
        copy( "$extra_path/sws.js", "$opt_dir/extras/sws.js" ) or die;
        status "Wrote: $opt_dir/extras/sws.js";
        
        copy( "$extra_path/sws2.css", "$opt_dir/extras/sws2.css" ) or die;
        status "Wrote: $opt_dir/extras/sws2.css";
    } else {
        bomb "Could not find extras dir: checked $extra_path";
    }
} else {
    bomb "bad action: $action";
}

exit 0;
